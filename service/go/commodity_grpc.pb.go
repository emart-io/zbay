// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package zbay

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CommoditiesClient is the client API for Commodities service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommoditiesClient interface {
	Add(ctx context.Context, in *Commodity, opts ...grpc.CallOption) (*Commodity, error)
	Get(ctx context.Context, in *Commodity, opts ...grpc.CallOption) (*Commodity, error)
	Update(ctx context.Context, in *Commodity, opts ...grpc.CallOption) (*Commodity, error)
	List(ctx context.Context, in *User, opts ...grpc.CallOption) (Commodities_ListClient, error)
	Search(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (Commodities_SearchClient, error)
	Delete(ctx context.Context, in *Commodity, opts ...grpc.CallOption) (*empty.Empty, error)
}

type commoditiesClient struct {
	cc grpc.ClientConnInterface
}

func NewCommoditiesClient(cc grpc.ClientConnInterface) CommoditiesClient {
	return &commoditiesClient{cc}
}

func (c *commoditiesClient) Add(ctx context.Context, in *Commodity, opts ...grpc.CallOption) (*Commodity, error) {
	out := new(Commodity)
	err := c.cc.Invoke(ctx, "/zbay.Commodities/Add", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commoditiesClient) Get(ctx context.Context, in *Commodity, opts ...grpc.CallOption) (*Commodity, error) {
	out := new(Commodity)
	err := c.cc.Invoke(ctx, "/zbay.Commodities/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commoditiesClient) Update(ctx context.Context, in *Commodity, opts ...grpc.CallOption) (*Commodity, error) {
	out := new(Commodity)
	err := c.cc.Invoke(ctx, "/zbay.Commodities/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commoditiesClient) List(ctx context.Context, in *User, opts ...grpc.CallOption) (Commodities_ListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Commodities_ServiceDesc.Streams[0], "/zbay.Commodities/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &commoditiesListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Commodities_ListClient interface {
	Recv() (*Commodity, error)
	grpc.ClientStream
}

type commoditiesListClient struct {
	grpc.ClientStream
}

func (x *commoditiesListClient) Recv() (*Commodity, error) {
	m := new(Commodity)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *commoditiesClient) Search(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (Commodities_SearchClient, error) {
	stream, err := c.cc.NewStream(ctx, &Commodities_ServiceDesc.Streams[1], "/zbay.Commodities/Search", opts...)
	if err != nil {
		return nil, err
	}
	x := &commoditiesSearchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Commodities_SearchClient interface {
	Recv() (*Commodity, error)
	grpc.ClientStream
}

type commoditiesSearchClient struct {
	grpc.ClientStream
}

func (x *commoditiesSearchClient) Recv() (*Commodity, error) {
	m := new(Commodity)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *commoditiesClient) Delete(ctx context.Context, in *Commodity, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/zbay.Commodities/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommoditiesServer is the server API for Commodities service.
// All implementations must embed UnimplementedCommoditiesServer
// for forward compatibility
type CommoditiesServer interface {
	Add(context.Context, *Commodity) (*Commodity, error)
	Get(context.Context, *Commodity) (*Commodity, error)
	Update(context.Context, *Commodity) (*Commodity, error)
	List(*User, Commodities_ListServer) error
	Search(*wrappers.StringValue, Commodities_SearchServer) error
	Delete(context.Context, *Commodity) (*empty.Empty, error)
	mustEmbedUnimplementedCommoditiesServer()
}

// UnimplementedCommoditiesServer must be embedded to have forward compatible implementations.
type UnimplementedCommoditiesServer struct {
}

func (UnimplementedCommoditiesServer) Add(context.Context, *Commodity) (*Commodity, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedCommoditiesServer) Get(context.Context, *Commodity) (*Commodity, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedCommoditiesServer) Update(context.Context, *Commodity) (*Commodity, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedCommoditiesServer) List(*User, Commodities_ListServer) error {
	return status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedCommoditiesServer) Search(*wrappers.StringValue, Commodities_SearchServer) error {
	return status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedCommoditiesServer) Delete(context.Context, *Commodity) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedCommoditiesServer) mustEmbedUnimplementedCommoditiesServer() {}

// UnsafeCommoditiesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommoditiesServer will
// result in compilation errors.
type UnsafeCommoditiesServer interface {
	mustEmbedUnimplementedCommoditiesServer()
}

func RegisterCommoditiesServer(s grpc.ServiceRegistrar, srv CommoditiesServer) {
	s.RegisterService(&Commodities_ServiceDesc, srv)
}

func _Commodities_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Commodity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommoditiesServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zbay.Commodities/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommoditiesServer).Add(ctx, req.(*Commodity))
	}
	return interceptor(ctx, in, info, handler)
}

func _Commodities_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Commodity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommoditiesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zbay.Commodities/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommoditiesServer).Get(ctx, req.(*Commodity))
	}
	return interceptor(ctx, in, info, handler)
}

func _Commodities_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Commodity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommoditiesServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zbay.Commodities/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommoditiesServer).Update(ctx, req.(*Commodity))
	}
	return interceptor(ctx, in, info, handler)
}

func _Commodities_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(User)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CommoditiesServer).List(m, &commoditiesListServer{stream})
}

type Commodities_ListServer interface {
	Send(*Commodity) error
	grpc.ServerStream
}

type commoditiesListServer struct {
	grpc.ServerStream
}

func (x *commoditiesListServer) Send(m *Commodity) error {
	return x.ServerStream.SendMsg(m)
}

func _Commodities_Search_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrappers.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CommoditiesServer).Search(m, &commoditiesSearchServer{stream})
}

type Commodities_SearchServer interface {
	Send(*Commodity) error
	grpc.ServerStream
}

type commoditiesSearchServer struct {
	grpc.ServerStream
}

func (x *commoditiesSearchServer) Send(m *Commodity) error {
	return x.ServerStream.SendMsg(m)
}

func _Commodities_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Commodity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommoditiesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zbay.Commodities/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommoditiesServer).Delete(ctx, req.(*Commodity))
	}
	return interceptor(ctx, in, info, handler)
}

// Commodities_ServiceDesc is the grpc.ServiceDesc for Commodities service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Commodities_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "zbay.Commodities",
	HandlerType: (*CommoditiesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _Commodities_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Commodities_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Commodities_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Commodities_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "List",
			Handler:       _Commodities_List_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Search",
			Handler:       _Commodities_Search_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "commodity.proto",
}

// CouponsClient is the client API for Coupons service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CouponsClient interface {
	Add(ctx context.Context, in *Coupon, opts ...grpc.CallOption) (*Coupon, error)
	Get(ctx context.Context, in *Coupon, opts ...grpc.CallOption) (*Coupon, error)
	Update(ctx context.Context, in *Coupon, opts ...grpc.CallOption) (*Coupon, error)
	Delete(ctx context.Context, in *Coupon, opts ...grpc.CallOption) (*empty.Empty, error)
	List(ctx context.Context, in *User, opts ...grpc.CallOption) (Coupons_ListClient, error)
}

type couponsClient struct {
	cc grpc.ClientConnInterface
}

func NewCouponsClient(cc grpc.ClientConnInterface) CouponsClient {
	return &couponsClient{cc}
}

func (c *couponsClient) Add(ctx context.Context, in *Coupon, opts ...grpc.CallOption) (*Coupon, error) {
	out := new(Coupon)
	err := c.cc.Invoke(ctx, "/zbay.Coupons/Add", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *couponsClient) Get(ctx context.Context, in *Coupon, opts ...grpc.CallOption) (*Coupon, error) {
	out := new(Coupon)
	err := c.cc.Invoke(ctx, "/zbay.Coupons/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *couponsClient) Update(ctx context.Context, in *Coupon, opts ...grpc.CallOption) (*Coupon, error) {
	out := new(Coupon)
	err := c.cc.Invoke(ctx, "/zbay.Coupons/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *couponsClient) Delete(ctx context.Context, in *Coupon, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/zbay.Coupons/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *couponsClient) List(ctx context.Context, in *User, opts ...grpc.CallOption) (Coupons_ListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Coupons_ServiceDesc.Streams[0], "/zbay.Coupons/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &couponsListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Coupons_ListClient interface {
	Recv() (*Coupon, error)
	grpc.ClientStream
}

type couponsListClient struct {
	grpc.ClientStream
}

func (x *couponsListClient) Recv() (*Coupon, error) {
	m := new(Coupon)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CouponsServer is the server API for Coupons service.
// All implementations must embed UnimplementedCouponsServer
// for forward compatibility
type CouponsServer interface {
	Add(context.Context, *Coupon) (*Coupon, error)
	Get(context.Context, *Coupon) (*Coupon, error)
	Update(context.Context, *Coupon) (*Coupon, error)
	Delete(context.Context, *Coupon) (*empty.Empty, error)
	List(*User, Coupons_ListServer) error
	mustEmbedUnimplementedCouponsServer()
}

// UnimplementedCouponsServer must be embedded to have forward compatible implementations.
type UnimplementedCouponsServer struct {
}

func (UnimplementedCouponsServer) Add(context.Context, *Coupon) (*Coupon, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedCouponsServer) Get(context.Context, *Coupon) (*Coupon, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedCouponsServer) Update(context.Context, *Coupon) (*Coupon, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedCouponsServer) Delete(context.Context, *Coupon) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedCouponsServer) List(*User, Coupons_ListServer) error {
	return status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedCouponsServer) mustEmbedUnimplementedCouponsServer() {}

// UnsafeCouponsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CouponsServer will
// result in compilation errors.
type UnsafeCouponsServer interface {
	mustEmbedUnimplementedCouponsServer()
}

func RegisterCouponsServer(s grpc.ServiceRegistrar, srv CouponsServer) {
	s.RegisterService(&Coupons_ServiceDesc, srv)
}

func _Coupons_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Coupon)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CouponsServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zbay.Coupons/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CouponsServer).Add(ctx, req.(*Coupon))
	}
	return interceptor(ctx, in, info, handler)
}

func _Coupons_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Coupon)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CouponsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zbay.Coupons/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CouponsServer).Get(ctx, req.(*Coupon))
	}
	return interceptor(ctx, in, info, handler)
}

func _Coupons_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Coupon)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CouponsServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zbay.Coupons/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CouponsServer).Update(ctx, req.(*Coupon))
	}
	return interceptor(ctx, in, info, handler)
}

func _Coupons_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Coupon)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CouponsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zbay.Coupons/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CouponsServer).Delete(ctx, req.(*Coupon))
	}
	return interceptor(ctx, in, info, handler)
}

func _Coupons_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(User)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CouponsServer).List(m, &couponsListServer{stream})
}

type Coupons_ListServer interface {
	Send(*Coupon) error
	grpc.ServerStream
}

type couponsListServer struct {
	grpc.ServerStream
}

func (x *couponsListServer) Send(m *Coupon) error {
	return x.ServerStream.SendMsg(m)
}

// Coupons_ServiceDesc is the grpc.ServiceDesc for Coupons service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Coupons_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "zbay.Coupons",
	HandlerType: (*CouponsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _Coupons_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Coupons_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Coupons_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Coupons_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "List",
			Handler:       _Coupons_List_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "commodity.proto",
}

// CommentsClient is the client API for Comments service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommentsClient interface {
	Add(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Comment, error)
	Get(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Comment, error)
	Update(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Comment, error)
	Delete(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*empty.Empty, error)
	List(ctx context.Context, in *Commodity, opts ...grpc.CallOption) (Comments_ListClient, error)
}

type commentsClient struct {
	cc grpc.ClientConnInterface
}

func NewCommentsClient(cc grpc.ClientConnInterface) CommentsClient {
	return &commentsClient{cc}
}

func (c *commentsClient) Add(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Comment, error) {
	out := new(Comment)
	err := c.cc.Invoke(ctx, "/zbay.Comments/Add", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentsClient) Get(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Comment, error) {
	out := new(Comment)
	err := c.cc.Invoke(ctx, "/zbay.Comments/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentsClient) Update(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Comment, error) {
	out := new(Comment)
	err := c.cc.Invoke(ctx, "/zbay.Comments/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentsClient) Delete(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/zbay.Comments/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentsClient) List(ctx context.Context, in *Commodity, opts ...grpc.CallOption) (Comments_ListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Comments_ServiceDesc.Streams[0], "/zbay.Comments/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &commentsListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Comments_ListClient interface {
	Recv() (*Comment, error)
	grpc.ClientStream
}

type commentsListClient struct {
	grpc.ClientStream
}

func (x *commentsListClient) Recv() (*Comment, error) {
	m := new(Comment)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CommentsServer is the server API for Comments service.
// All implementations must embed UnimplementedCommentsServer
// for forward compatibility
type CommentsServer interface {
	Add(context.Context, *Comment) (*Comment, error)
	Get(context.Context, *Comment) (*Comment, error)
	Update(context.Context, *Comment) (*Comment, error)
	Delete(context.Context, *Comment) (*empty.Empty, error)
	List(*Commodity, Comments_ListServer) error
	mustEmbedUnimplementedCommentsServer()
}

// UnimplementedCommentsServer must be embedded to have forward compatible implementations.
type UnimplementedCommentsServer struct {
}

func (UnimplementedCommentsServer) Add(context.Context, *Comment) (*Comment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedCommentsServer) Get(context.Context, *Comment) (*Comment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedCommentsServer) Update(context.Context, *Comment) (*Comment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedCommentsServer) Delete(context.Context, *Comment) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedCommentsServer) List(*Commodity, Comments_ListServer) error {
	return status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedCommentsServer) mustEmbedUnimplementedCommentsServer() {}

// UnsafeCommentsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommentsServer will
// result in compilation errors.
type UnsafeCommentsServer interface {
	mustEmbedUnimplementedCommentsServer()
}

func RegisterCommentsServer(s grpc.ServiceRegistrar, srv CommentsServer) {
	s.RegisterService(&Comments_ServiceDesc, srv)
}

func _Comments_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentsServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zbay.Comments/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentsServer).Add(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Comments_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zbay.Comments/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentsServer).Get(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Comments_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentsServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zbay.Comments/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentsServer).Update(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Comments_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zbay.Comments/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentsServer).Delete(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Comments_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Commodity)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CommentsServer).List(m, &commentsListServer{stream})
}

type Comments_ListServer interface {
	Send(*Comment) error
	grpc.ServerStream
}

type commentsListServer struct {
	grpc.ServerStream
}

func (x *commentsListServer) Send(m *Comment) error {
	return x.ServerStream.SendMsg(m)
}

// Comments_ServiceDesc is the grpc.ServiceDesc for Comments service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Comments_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "zbay.Comments",
	HandlerType: (*CommentsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _Comments_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Comments_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Comments_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Comments_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "List",
			Handler:       _Comments_List_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "commodity.proto",
}
